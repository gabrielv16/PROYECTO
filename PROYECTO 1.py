# -*- coding: utf-8 -*-
"""PROYECTO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CzPQTyLKT2OS76QhSIoVnWeOm8Nif1Dv
"""

""""
Nicolas Sayago Victor Gabriel

Este Proyecto consta de retornar un tiempo minimo para la elaboracion de un proyecto y a su vez de sus distintas actividades de este,
intente hacerlo en google colab, pero al no poder generar el formato txt, recurri a Visual Studie Code (VSC), ya que este si lo permite,
solo cambiaron algunas cosas, como por ejemplo; el importar la carpeta desde drive, en vez de eso, ahora lo hace desde los archivos de la
computadora.
"""

import pandas as pd
import numpy as np

def leer_excel(archivo):
    df = pd.read_excel("C:\Users\LENOVO\Downloads\PROYECTO1.xlsx") # Colocamos la direccion, como vimos en clase
    return df

def construir_red(df):
    actividades = {} # Almacenamos la informacion con el diccionario
    nodo_inagural = None
    nodos_sin_continuador = set() # Nodos sin continuador

    for i, fila in df.iterrows(): # Iteramos
        actividad = fila['Actividad']
        descripcion = fila['Descripción']
        previos = fila['Previos']
        duracion = fila['Duración']

        if pd.isna(previos) or previos == '-':
            nodo_inagural = actividad
            previos = []  # Lista vacia
        else:
            previos = [int(p) for p in str(previos).split(',') if p]  # Convierte los previos en una lista de enteros.

        actividades[actividad] = {'descripcion': descripcion,  # Almacena la información de la actividad en el diccionario.
                                  'previos': previos,
                                  'duracion': duracion,
                                  'continuadores': []} #Lista vacia

        nodos_sin_continuador.add(actividad) # Nodos sin continuador

        for p in previos:  # Itera sobre los previos.
            if p in actividades:  # Comprueba si el previo existe en las actividades.
                actividades[p]['continuadores'].append(actividad)  # Agrega la actividad como continuador del previo.
                nodos_sin_continuador.discard(p)
            else:
                print(f"Advertencia: La actividad {p} no existe y se omitirá como precedente de {actividad}.")  # Advierte si un previo no existe.

    if len(nodos_sin_continuador) != 1:
        raise ValueError("Debe haber exactamente un nodo final sin continuador.")  # Lanza un error si no se cumple la condición.

    nodo_final = next(iter(nodos_sin_continuador))  # Nodo final del conjunto de nodos sin continuador.

    return actividades, nodo_inagural, nodo_final  # Retorna la información de las actividades, el nodo inagural y el nodo final.

def calcular_fechas(actividades, nodo_inagural, nodo_final):
    fechas_mas_cercanas = {}  # Diccionario para las fechas cercanas.
    fechas_mas_distantes = {}  # Diccionario para las fechas lejanas.

    def calcular_fechas_rec(nodo, tiempo_almacenado):
        if nodo not in fechas_mas_cercanas:  # Comprueba si el nodo no tiene fecha más cercana.
            fechas_mas_cercanas[nodo] = tiempo_almacenado  # Asigna el tiempo acumulado como la fecha más cercana.
        else:
            fechas_mas_cercanas[nodo] = max(fechas_mas_cercanas[nodo], tiempo_almacenado)  # Actualiza la fecha más cercana si es necesario.

        tiempo_almacenado += actividades[nodo]['duracion']  # Incrementa el tiempo almacenado con la duración de la actividad.

        if nodo not in fechas_mas_distantes:  # Comprueba si el nodo no tiene fecha más distante.
            fechas_mas_distantes[nodo] = tiempo_almacenado  # Asigna el tiempo acumulado como la fecha más distante.
        else:
            fechas_mas_distantes[nodo] = max(fechas_mas_distantes[nodo], tiempo_almacenado)  # Actualiza la fecha más distante si es necesario.

        for contin in actividades[nodo]['continuadores']:  # Itera sobre los continuadores del nodo.
            calcular_fechas_rec(contin, tiempo_almacenado)

    calcular_fechas_rec(nodo_inagural, 0)  # Llama a la función interna para calcular las fechas desde el nodo inicial.

    return fechas_mas_cercanas, fechas_mas_distantes  # Regresa las fechas más próximas y más lejanas para cada actividad.

def crear_reporte(actividades, nodo_inagural, nodo_final, fechas_mas_cercanas, fechas_mas_distantes):
    tiempo_min = fechas_mas_distantes[nodo_final]  # Obtiene el tiempo mínimo necesario para el proyecto.
    actividades_criticas = []  # Inicializa una lista para almacenar las actividades críticas.

    for actividad, info in actividades.items():  # Itera sobre las actividades.
        if fechas_mas_cercanas[actividad] == fechas_mas_distantes[actividad] - info['duracion']:  # Comprueba si la actividad es crítica.
            actividades_criticas.append(f"{actividad}. {info['descripcion']}")  # Agrega la actividad a la lista de actividades críticas.

    with open('reporte.txt', 'w', encoding='utf-8') as f: # Abre el reporte txt
        f.write(f"El tiempo necesario para la elaboración del proyecto es de {tiempo_min} semanas.\n\n")
        f.write("Las actividades críticas son:\n\n")
        for actividad in actividades_criticas:
            f.write(f"{actividad},\n")  # Escribe cada actividad crítica en el reporte.

def main():  # Define el programa.
    archivo_excel = 'PROYECTO1.xlsx'
    df = leer_excel(archivo_excel)
    actividades, nodo_inagural, nodo_final = construir_red(df)
    fechas_mas_cercanas, fechas_mas_distantes = calcular_fechas(actividades, nodo_inagural, nodo_final)  # Calcula las fechas inagurales y finales
    crear_reporte(actividades, nodo_inagural, nodo_final, fechas_mas_cercanas, fechas_mas_distantes)  # Crea el reporte txt

if __name__ == '_main_':
    main()